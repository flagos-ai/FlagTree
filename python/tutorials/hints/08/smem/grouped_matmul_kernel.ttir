#loc1 = loc("group_a_ptrs")
#loc2 = loc("group_b_ptrs")
#loc3 = loc("group_c_ptrs")
#loc4 = loc("group_gemm_sizes")
#loc5 = loc("g_lds")
#loc6 = loc("group_size")
#loc7 = loc("tile_idx")
module {
  tt.func public @grouped_matmul_kernel(%group_a_ptrs: !tt.ptr<i64> {tt.divisibility = 16 : i32} loc("group_a_ptrs"), %group_b_ptrs: !tt.ptr<i64> {tt.divisibility = 16 : i32} loc("group_b_ptrs"), %group_c_ptrs: !tt.ptr<i64> {tt.divisibility = 16 : i32} loc("group_c_ptrs"), %group_gemm_sizes: !tt.ptr<i32> {tt.divisibility = 16 : i32} loc("group_gemm_sizes"), %g_lds: !tt.ptr<i32> {tt.divisibility = 16 : i32} loc("g_lds"), %group_size: i32 loc("group_size")) attributes {noinline = false} {
    %c63_i32 = arith.constant 63 : i32 loc(#loc)
    %c127_i32 = arith.constant 127 : i32 loc(#loc)
    %c132_i32 = arith.constant 132 : i32 loc(#loc)
    %cst = arith.constant dense<64> : tensor<128x64xi32> loc(#loc)
    %c64_i32 = arith.constant 64 : i32 loc(#loc)
    %cst_0 = arith.constant dense<0.000000e+00> : tensor<128x128xf32> loc(#loc)
    %c128_i32 = arith.constant 128 : i32 loc(#loc)
    %c2_i32 = arith.constant 2 : i32 loc(#loc)
    %c3_i32 = arith.constant 3 : i32 loc(#loc)
    %c1_i32 = arith.constant 1 : i32 loc(#loc)
    %c0_i32 = arith.constant 0 : i32 loc(#loc)
    %0 = tt.get_program_id x : i32 loc(#loc)
    %last_problem_end:2 = scf.for %g = %c0_i32 to %group_size step %c1_i32 iter_args(%tile_idx = %0, %last_problem_end_1 = %c0_i32) -> (i32, i32)  : i32 {
      %1 = arith.muli %g, %c3_i32 : i32 loc(#loc)
      %2 = tt.addptr %group_gemm_sizes, %1 : !tt.ptr<i32>, i32 loc(#loc)
      %3 = tt.load %2 : !tt.ptr<i32> loc(#loc)
      %4 = tt.addptr %2, %c1_i32 : !tt.ptr<i32>, i32 loc(#loc)
      %5 = tt.load %4 : !tt.ptr<i32> loc(#loc)
      %6 = tt.addptr %2, %c2_i32 : !tt.ptr<i32>, i32 loc(#loc)
      %7 = tt.load %6 : !tt.ptr<i32> loc(#loc)
      %8 = arith.addi %3, %c127_i32 : i32 loc(#loc)
      %9 = arith.divsi %8, %c128_i32 : i32 loc(#loc)
      %10 = arith.addi %5, %c127_i32 : i32 loc(#loc)
      %11 = arith.divsi %10, %c128_i32 : i32 loc(#loc)
      %12 = arith.muli %9, %11 : i32 loc(#loc)
      %tile_idx_2 = scf.while (%tile_idx_3 = %tile_idx) : (i32) -> i32 {
        %14 = arith.cmpi sge, %tile_idx_3, %last_problem_end_1 : i32 loc(#loc)
        %15 = arith.addi %last_problem_end_1, %12 : i32 loc(#loc)
        %16 = arith.cmpi slt, %tile_idx_3, %15 : i32 loc(#loc)
        %17 = arith.andi %14, %16 : i1 loc(#loc)
        scf.condition(%17) %tile_idx_3 : i32 loc(#loc)
      } do {
      ^bb0(%tile_idx_3: i32 loc("tile_idx")):
        %14 = tt.addptr %g_lds, %1 : !tt.ptr<i32>, i32 loc(#loc)
        %15 = tt.load %14 : !tt.ptr<i32> loc(#loc)
        %16 = tt.addptr %14, %c1_i32 : !tt.ptr<i32>, i32 loc(#loc)
        %17 = tt.load %16 : !tt.ptr<i32> loc(#loc)
        %18 = tt.addptr %14, %c2_i32 : !tt.ptr<i32>, i32 loc(#loc)
        %19 = tt.load %18 : !tt.ptr<i32> loc(#loc)
        %20 = tt.addptr %group_a_ptrs, %g : !tt.ptr<i64>, i32 loc(#loc)
        %21 = tt.load %20 : !tt.ptr<i64> loc(#loc)
        %22 = tt.int_to_ptr %21 : i64 -> !tt.ptr<f16> loc(#loc)
        %23 = tt.addptr %group_b_ptrs, %g : !tt.ptr<i64>, i32 loc(#loc)
        %24 = tt.load %23 : !tt.ptr<i64> loc(#loc)
        %25 = tt.int_to_ptr %24 : i64 -> !tt.ptr<f16> loc(#loc)
        %26 = tt.addptr %group_c_ptrs, %g : !tt.ptr<i64>, i32 loc(#loc)
        %27 = tt.load %26 : !tt.ptr<i64> loc(#loc)
        %28 = tt.int_to_ptr %27 : i64 -> !tt.ptr<f16> loc(#loc)
        %29 = arith.subi %tile_idx_3, %last_problem_end_1 : i32 loc(#loc)
        %30 = arith.divsi %29, %11 : i32 loc(#loc)
        %31 = arith.remsi %29, %11 : i32 loc(#loc)
        %32 = arith.muli %30, %c128_i32 : i32 loc(#loc)
        %33 = tt.make_range {end = 128 : i32, start = 0 : i32} : tensor<128xi32> loc(#loc)
        %34 = tt.splat %32 : i32 -> tensor<128xi32> loc(#loc)
        %35 = arith.addi %34, %33 : tensor<128xi32> loc(#loc)
        %36 = arith.muli %31, %c128_i32 : i32 loc(#loc)
        %37 = tt.splat %36 : i32 -> tensor<128xi32> loc(#loc)
        %38 = arith.addi %37, %33 : tensor<128xi32> loc(#loc)
        %39 = tt.make_range {end = 64 : i32, start = 0 : i32} : tensor<64xi32> loc(#loc)
        %40 = tt.expand_dims %35 {axis = 1 : i32} : tensor<128xi32> -> tensor<128x1xi32> loc(#loc)
        %41 = tt.splat %15 : i32 -> tensor<128x1xi32> loc(#loc)
        %42 = arith.muli %40, %41 : tensor<128x1xi32> loc(#loc)
        %43 = tt.splat %22 : !tt.ptr<f16> -> tensor<128x1x!tt.ptr<f16>> loc(#loc)
        %44 = tt.addptr %43, %42 : tensor<128x1x!tt.ptr<f16>>, tensor<128x1xi32> loc(#loc)
        %45 = tt.expand_dims %39 {axis = 0 : i32} : tensor<64xi32> -> tensor<1x64xi32> loc(#loc)
        %46 = tt.broadcast %44 : tensor<128x1x!tt.ptr<f16>> -> tensor<128x64x!tt.ptr<f16>> loc(#loc)
        %47 = tt.broadcast %45 : tensor<1x64xi32> -> tensor<128x64xi32> loc(#loc)
        %48 = tt.addptr %46, %47 {tt.divisibility = dense<16> : tensor<2xi32>} : tensor<128x64x!tt.ptr<f16>>, tensor<128x64xi32> loc(#loc)
        %49 = tt.expand_dims %39 {axis = 1 : i32} : tensor<64xi32> -> tensor<64x1xi32> loc(#loc)
        %50 = tt.splat %17 : i32 -> tensor<64x1xi32> loc(#loc)
        %51 = arith.muli %49, %50 : tensor<64x1xi32> loc(#loc)
        %52 = tt.splat %25 : !tt.ptr<f16> -> tensor<64x1x!tt.ptr<f16>> loc(#loc)
        %53 = tt.addptr %52, %51 : tensor<64x1x!tt.ptr<f16>>, tensor<64x1xi32> loc(#loc)
        %54 = tt.expand_dims %38 {axis = 0 : i32} : tensor<128xi32> -> tensor<1x128xi32> loc(#loc)
        %55 = tt.broadcast %53 : tensor<64x1x!tt.ptr<f16>> -> tensor<64x128x!tt.ptr<f16>> loc(#loc)
        %56 = tt.broadcast %54 : tensor<1x128xi32> -> tensor<64x128xi32> loc(#loc)
        %57 = tt.addptr %55, %56 {tt.divisibility = dense<16> : tensor<2xi32>} : tensor<64x128x!tt.ptr<f16>>, tensor<64x128xi32> loc(#loc)
        %58 = arith.addi %7, %c63_i32 : i32 loc(#loc)
        %59 = arith.divsi %58, %c64_i32 : i32 loc(#loc)
        %accumulator:3 = scf.for %kk = %c0_i32 to %59 step %c1_i32 iter_args(%a_ptrs = %48, %b_ptrs = %57, %accumulator_4 = %cst_0) -> (tensor<128x64x!tt.ptr<f16>>, tensor<64x128x!tt.ptr<f16>>, tensor<128x128xf32>)  : i32 {
          %69 = tt.load %a_ptrs {flagtree_hints = "shared_memory"} : tensor<128x64x!tt.ptr<f16>> loc(#loc)
          %70 = tt.load %b_ptrs {flagtree_hints = "shared_memory"} : tensor<64x128x!tt.ptr<f16>> loc(#loc)
          %71 = tt.dot %69, %70, %accumulator_4, inputPrecision = tf32 : tensor<128x64xf16> * tensor<64x128xf16> -> tensor<128x128xf32> loc(#loc)
          %72 = tt.addptr %a_ptrs, %cst : tensor<128x64x!tt.ptr<f16>>, tensor<128x64xi32> loc(#loc)
          %73 = arith.muli %17, %c64_i32 : i32 loc(#loc)
          %74 = tt.splat %73 : i32 -> tensor<64x128xi32> loc(#loc)
          %75 = tt.addptr %b_ptrs, %74 : tensor<64x128x!tt.ptr<f16>>, tensor<64x128xi32> loc(#loc)
          scf.yield %72, %75, %71 : tensor<128x64x!tt.ptr<f16>>, tensor<64x128x!tt.ptr<f16>>, tensor<128x128xf32> loc(#loc)
        } {tt.divisibility_arg1 = dense<16> : tensor<2xi32>, tt.divisibility_arg2 = dense<16> : tensor<2xi32>} loc(#loc11)
        %60 = arith.truncf %accumulator#2 : tensor<128x128xf32> to tensor<128x128xf16> loc(#loc)
        %61 = tt.splat %19 : i32 -> tensor<128x1xi32> loc(#loc)
        %62 = arith.muli %61, %40 : tensor<128x1xi32> loc(#loc)
        %63 = tt.splat %28 : !tt.ptr<f16> -> tensor<128x1x!tt.ptr<f16>> loc(#loc)
        %64 = tt.addptr %63, %62 : tensor<128x1x!tt.ptr<f16>>, tensor<128x1xi32> loc(#loc)
        %65 = tt.broadcast %64 : tensor<128x1x!tt.ptr<f16>> -> tensor<128x128x!tt.ptr<f16>> loc(#loc)
        %66 = tt.broadcast %54 : tensor<1x128xi32> -> tensor<128x128xi32> loc(#loc)
        %67 = tt.addptr %65, %66 : tensor<128x128x!tt.ptr<f16>>, tensor<128x128xi32> loc(#loc)
        tt.store %67, %60 : tensor<128x128x!tt.ptr<f16>> loc(#loc)
        %68 = arith.addi %tile_idx_3, %c132_i32 : i32 loc(#loc)
        scf.yield %68 : i32 loc(#loc)
      } loc(#loc7)
      %13 = arith.addi %last_problem_end_1, %12 : i32 loc(#loc)
      scf.yield %tile_idx_2, %13 : i32, i32 loc(#loc)
    } loc(#loc9)
    tt.return loc(#loc)
  } loc(#loc)
} loc(#loc)
#loc = loc(unknown)
#loc8 = loc("a_ptrs")
#loc9 = loc("last_problem_end"(#loc7))
#loc10 = loc("b_ptrs"(#loc8))
#loc11 = loc("accumulator"(#loc10))
